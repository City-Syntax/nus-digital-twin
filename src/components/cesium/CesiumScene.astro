---
import 'cesium/Build/Cesium/Widgets/widgets.css';
---

<script>
  window.CESIUM_BASE_URL = '/cesium';
  Ion.defaultAccessToken = import.meta.env.PUBLIC_CESIUM_TOKEN;

  import {
    activePage,
    activeModel,
    buildingId,
    activeMapLayer,
    buildingColorSetting,
    isSelectColorByDistance,
    colorByDistancePosition,
  } from '../../store';
  import {
    Cartesian2,
    Cartesian3,
    createOsmBuildingsAsync,
    Ion,
    Math as CesiumMath,
    Terrain,
    Viewer,
    Cesium3DTileStyle,
    ScreenSpaceEventType,
    defined,
    MapboxStyleImageryProvider,
    JulianDate,
    Cesium3DTileset,
    ClippingPlaneCollection,
    ClippingPlane,
    Transforms,
    IonImageryProvider,
    ImageryLayer,
    EllipsoidGeodesic,
    Ray,
  } from 'cesium';
  import { OSM_DISTANCE_COLORS, OSM_SHOW_CONDITIONS } from './cesiumSceneUtils';
  import type { MapLayers } from '../../types';

  // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
  const viewer = new Viewer('cesiumContainer', {
    terrain: Terrain.fromWorldTerrain(),
    navigationHelpButton: false,
    homeButton: false,
    fullscreenButton: false,
    baseLayerPicker: false,
    sceneModePicker: false,
    animation: false, // Disables the Cesium animation clock
    geocoder: false, // Disables the Cesium search button
    baseLayer: ImageryLayer.fromProviderAsync(IonImageryProvider.fromAssetId(3954), {}), // Default to Sentinel-2 base layer
  });

  const globe = viewer.scene.globe;

  // @ts-ignore: https://community.cesium.com/t/change-timeline-from-utc-to-local-time/11203/7
  viewer.timeline.makeLabel = function (timelineDate: any) {
    const date = JulianDate.toDate(timelineDate);
    const dateFormatter = new Intl.DateTimeFormat('en-SG', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: false,
    });

    return dateFormatter.format(date);
  };

  // Limit amount to zoom in and out to
  viewer.scene.screenSpaceCameraController.minimumZoomDistance = 100.0;
  viewer.scene.screenSpaceCameraController.maximumZoomDistance = 10000.0;

  // Increase the tileCacheSize
  const DEFAULT_TILE_CACHE_SIZE = 100;
  globe.tileCacheSize = DEFAULT_TILE_CACHE_SIZE * 8;

  // Simulate loading percentage until map tiles are requested
  const loadingPercentage = document.querySelector('#loading-percentage')!;
  const loadingProgress = document.getElementById('loading-progress')!;
  const offsetPercent = 40;
  (function addLoadPercentUntilOffset() {
    setTimeout(() => {
      const currPercent = Number(loadingPercentage.textContent);
      if (currPercent >= offsetPercent) {
        return;
      }
      const newPercent = currPercent + Math.floor(Math.random() * 3);
      loadingPercentage.textContent = `${newPercent}`;
      loadingProgress.style.transform = `translateX(-${100 - newPercent}%)`;
      addLoadPercentUntilOffset();
    }, 100);
  })();

  const mapboxSatellite = new MapboxStyleImageryProvider({
    styleId: 'satellite-v9',
    accessToken: import.meta.env.PUBLIC_MAPBOX_TOKEN,
  });
  const mapboxDark = new MapboxStyleImageryProvider({
    styleId: 'dark-v11',
    accessToken: import.meta.env.PUBLIC_MAPBOX_TOKEN,
  });
  const mapboxStreet = new MapboxStyleImageryProvider({
    styleId: 'streets-v12',
    accessToken: import.meta.env.PUBLIC_MAPBOX_TOKEN,
  });

  // The displayed map layer is the last layer
  let mapLayerOrder: MapLayers[] = ['satellite', 'dark', 'street'];
  const showMapbox = import.meta.env.PROD || import.meta.env.PUBLIC_SHOW_MAPBOX === 'true';
  if (showMapbox) {
    viewer.imageryLayers.removeAll();
    viewer.imageryLayers.addImageryProvider(mapboxStreet);
    viewer.imageryLayers.lowerToBottom(viewer.imageryLayers.addImageryProvider(mapboxDark));
    viewer.imageryLayers.lowerToBottom(viewer.imageryLayers.addImageryProvider(mapboxSatellite));
  } else {
    document.getElementById('loading-modal')?.remove();
  }

  const position = Cartesian3.fromDegrees(103.77678, 1.28342, 800);

  let nusView = {
    destination: position,
    orientation: {
      heading: CesiumMath.toRadians(0.0),
      pitch: CesiumMath.toRadians(-30.0),
    },
  };
  viewer.camera.setView(nusView);
  document.getElementById('home-btn')!.onclick = () => viewer.camera.flyTo(nusView);

  const osmBuildingsTileset = await createOsmBuildingsAsync();
  osmBuildingsTileset.clippingPlanes = new ClippingPlaneCollection({
    modelMatrix: Transforms.eastNorthUpToFixedFrame(position),
    planes: [
      new ClippingPlane(new Cartesian3(1.0, 0.0, 0.0), 850),
      new ClippingPlane(new Cartesian3(-1.0, 0.0, 0.0), 700),
      new ClippingPlane(new Cartesian3(0.0, 1.0, 0.0), -600),
      new ClippingPlane(new Cartesian3(0.0, -1.0, 0.0), 2800),
    ],
    unionClippingRegions: true,
  });
  osmBuildingsTileset.style = new Cesium3DTileStyle({
    show: { conditions: OSM_SHOW_CONDITIONS },
  });
  osmBuildingsTileset.maximumScreenSpaceError = 0;
  osmBuildingsTileset.preloadWhenHidden = true;
  viewer.scene.primitives.add(osmBuildingsTileset);

  const sde4Id = 2464285;
  const yncId = 2463878;
  const sde4 = await Cesium3DTileset.fromIonAssetId(sde4Id);
  const ync = await Cesium3DTileset.fromIonAssetId(yncId);
  const bimModels = [sde4, ync];
  for (let i = 0; i < bimModels.length; i++) {
    viewer.scene.primitives.add(bimModels[i]);
    bimModels[i].show = false;
    bimModels[i].preloadWhenHidden = true;
  }

  function showAllBIM() {
    for (let i = 0; i < bimModels.length; i++) {
      bimModels[i].show = true;
    }
  }

  function hideAllBIM() {
    for (let i = 0; i < bimModels.length; i++) {
      bimModels[i].show = false;
    }
  }

  function colorByDistance(selectedLatitude: number, selectedLongitude: number) {
    colorByDistancePosition.set({
      latitude: selectedLatitude,
      longitude: selectedLongitude,
    });

    osmBuildingsTileset.style = new Cesium3DTileStyle({
      defines: {
        distance: `distance(vec2(\${feature['cesium#longitude']}, \${feature['cesium#latitude']}), vec2(${selectedLongitude},${selectedLatitude}))`,
      },
      color: { conditions: OSM_DISTANCE_COLORS },
      show: { conditions: OSM_SHOW_CONDITIONS },
    });
  }

  function colorByNone() {
    osmBuildingsTileset.style = new Cesium3DTileStyle({ show: { conditions: OSM_SHOW_CONDITIONS } });
  }

  const handler = viewer.screenSpaceEventHandler;
  handler.setInputAction(function (movement: any) {
    const pickedFeature = viewer.scene.pick(movement.position);
    if (!defined(pickedFeature)) {
      return;
    }

    if (isSelectColorByDistance.get()) {
      colorByDistance(pickedFeature.getProperty('cesium#latitude'), pickedFeature.getProperty('cesium#longitude'));
      isSelectColorByDistance.set(false);
      return;
    }

    activePage.set('building-info');
    if (bimModels.includes(pickedFeature.primitive)) {
      const resourceUrl = pickedFeature.primitive.resource.url;

      if (resourceUrl.includes(yncId)) {
        buildingId.set('732229050');
      }

      if (resourceUrl.includes(sde4Id)) {
        buildingId.set('628774809');
      }

      return;
    }

    buildingId.set(pickedFeature.getProperty('elementId'));
  }, ScreenSpaceEventType.LEFT_CLICK);

  buildingColorSetting.subscribe((colorSetting) => {
    if (colorSetting === 'distance') {
      const { latitude, longitude } = colorByDistancePosition.get();
      colorByDistance(latitude, longitude);
    } else {
      colorByNone();
    }
  });

  activeModel.subscribe((model) => {
    if (model === 'osm') {
      osmBuildingsTileset.show = true;
    } else {
      osmBuildingsTileset.show = false;
    }

    if (model === 'bim') {
      showAllBIM();
    } else {
      hideAllBIM();
    }
  });

  activeMapLayer.subscribe((selectedMapLayer) => {
    if (!showMapbox) {
      return;
    }

    viewer.imageryLayers.raiseToTop(viewer.imageryLayers.get(mapLayerOrder.indexOf(selectedMapLayer)));
    mapLayerOrder = [...mapLayerOrder.filter((l) => l !== selectedMapLayer), selectedMapLayer];
  });

  let totalTiles = 0;
  function tileLoadProgressListener(queuedTiles: number) {
    const prevTotalTiles = totalTiles;
    totalTiles = Math.max(totalTiles, queuedTiles);

    if (prevTotalTiles == totalTiles) {
      const currPercent = Number(loadingPercentage.textContent);
      const newPercent = offsetPercent + Math.round(((totalTiles - queuedTiles) / totalTiles) * (100 - offsetPercent));
      if (newPercent > currPercent) {
        loadingPercentage.textContent = `${newPercent}`;
        loadingProgress.style.transform = `translateX(-${100 - newPercent}%)`;
      }
    }

    if (globe.tilesLoaded && osmBuildingsTileset.allTilesLoaded) {
      // Preload siblings only after first load
      globe.preloadSiblings = true;

      updateDistanceScale();

      // Outer timeout is required for the translate animation to complete
      setTimeout(() => {
        document.getElementById('loading-modal')?.classList.add('close');
        setTimeout(() => {
          document.getElementById('loading-modal')?.remove();
        }, 200);
      }, 350);
      globe.tileLoadProgressEvent.removeEventListener(tileLoadProgressListener);
    }
  }

  globe.tileLoadProgressEvent.addEventListener(tileLoadProgressListener);

  const geodesic = new EllipsoidGeodesic();
  const distances = [1, 2, 3, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 100, 200, 300, 500, 1000];
  const width = viewer.scene.canvas.clientWidth;
  const height = viewer.scene.canvas.clientHeight;
  const scaleLabel = document.getElementById('scale-label')!;
  const scaleBar = document.getElementById('scale-bar')!;
  function updateDistanceScale() {
    const left = viewer.scene.camera.getPickRay(new Cartesian2((width / 2) | 0, height - 1));
    const right = viewer.scene.camera.getPickRay(new Cartesian2((1 + width / 2) | 0, height - 1));

    if (!left || !right) {
      return;
    }

    const leftPosition = globe.pick(left, viewer.scene);
    const rightPosition = globe.pick(right, viewer.scene);

    if (!leftPosition || !rightPosition) {
      return;
    }

    const leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
    const rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);

    geodesic.setEndPoints(leftCartographic, rightCartographic);
    const pixelDistance = geodesic.surfaceDistance;
    // Find the first distance that makes the scale bar less than 100 pixels.
    const maxBarWidth = 100;
    let distance;
    for (let i = distances.length - 1; !defined(distance) && i >= 0; --i) {
      if (distances[i] / pixelDistance < maxBarWidth) {
        distance = distances[i];
      }
    }

    if (defined(distance)) {
      let label;
      if (distance >= 1000) {
        label = (distance / 1000).toString() + ' km';
      } else {
        label = distance.toString() + ' m';
      }

      const barWidth = distance / pixelDistance;
      scaleBar.style.width = barWidth + 'px';
      scaleLabel.textContent = label;
    }
  }

  viewer.camera.moveEnd.addEventListener(function () {
    updateDistanceScale();
  });
</script>

<div id="cesiumContainer"></div>
<div id="loading-modal">
  <h1>NUS Digital Twin</h1>
  <div>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
    <div id="loading-text">
      Loading...<span id="loading-percentage">0</span>%
    </div>
  </div>
</div>
